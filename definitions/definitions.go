package definitions

// definitions is used to auto-generate the cmd/autogenerated.go file.
// It makes heavy use of Golang templates and uses the definitions.tom
// file in order to generate the golang code.

import (
	"bytes"
	"fmt"
	"io/ioutil"
	"strings"
	"text/template"

	"github.com/BurntSushi/toml"
)

const (
	// goTemplate is a high level template for the autogenerated.go file
	goTemplate = `
package cmd

var (
{{ .Variables }}
)

func init() {
{{ .Commands }}
}

func Run(cmd *cobra.Command, args []string, name string, api *cloudflare.API) (resp interface{}, err error) {
  {{ .SwitchList }}
  return
}
`

	switchTemplate = `switch name {
  {{ range . }}
  case "{{.Name}}":
    resp, err = {{.Name}}(api, {{.ArgList}}){{ end }}
  default:
    break
}`
	// varTemplate is the template used by each subcommand to declare
	// their command line flags as Golang code.
	varTemplate = `{{ range .}}{{ .Name }} {{ .Type }}
{{ end }}`

	// cmdTemplate is very hairy, and used to declare
	// top-level cli commands and their subcommands.
	// Top level commands are added to the root command
	// while subcommands will call the `Main` function
	// and pass their subcommand name, which is used
	// to route to the proper case within the switch.
	cmdTemplate = `var {{.VariableName}} = &cobra.Command{
  Use:   "{{- .Name -}}",
  Short: "{{- .ShortDescription -}}",
  Long: ` + "`" + `{{- .Description -}}` + "`" + `,
{{ if .V4APIName}}Run: func(cmd *cobra.Command, args []string) {
    Main(cmd, args, "{{- .V4APIName}}")
  },{{ end}}
}
{{- $varName := .VariableName }}
{{range .Subcommands}}{{$varName}}.AddCommand({{.}})
{{end}}
{{ if .TopLevel }}RootCmd.AddCommand({{.VariableName}})
{{ end }}
{{range .Option}}
  {{$varName}}.Flags().{{.TypeCap}}Var(&{{.ArgName}}, "{{.Name}}", {{.Default}}, "{{.Description}}")
  {{if .Required}}{{$varName}}.MarkFlagRequired("{{.Name}}")
{{end}}
{{end}}
`
)

var (
	// declaredVariables keeps track of which variables have already
	// been declared in our Go file. It will cause a compile time
	// issue if the same variable is declared twice.
	declaredVariables = make(map[string]bool)
)

// Option is a command line option that can be passed to
// the program. Commands "have a" set of Options.
type Option struct {
	Name        string
	Type        string
	Description string
	Required    bool
}

type OptionTemplateValue struct {
	TypeCap     string
	ArgName     string
	Name        string
	Default     string
	Description string
	Required    bool
}

type SwitchTemplateEntry struct {
	Name    string
	ArgList string
}

// Command is a toplevel or subcommand.
// They have a set of subcommands if they are toplevel
// and V4APIName will be set to the name of the Switch
// case that is associated with the subcommand name.
// For Example: list-zones will have a switch case named
// ListZones, and ListZones should call the cloudflare-go
// method api.ListZones.
type Command struct {
	Name             string
	Description      string
	ShortDescription string
	V4APIName        string
	Option           []Option
	Subcommands      []string
	TopLevel         bool
}

type CommandTemplateValues struct {
	Name             string
	VariableName     string
	V4APIName        string
	Description      string
	ShortDescription string
	Option           []OptionTemplateValue

	Subcommands []string
	TopLevel    bool
}

type FileTemplateValues struct {
	Commands   string
	Variables  string
	SwitchList string
}

func fileText(commands, variables, switchList string) (string, error) {
	var (
		buff bytes.Buffer
	)
	tmpl, err := template.New("gofile").Parse(goTemplate)
	if err != nil {
		return "", err
	}
	err = tmpl.Execute(&buff, &FileTemplateValues{
		Commands:   commands,
		Variables:  variables,
		SwitchList: switchList,
	})
	if err != nil {
		return "", err
	}
	return buff.String(), nil
}

func (o Option) ToOptionTemplateValue() OptionTemplateValue {
	// When declaring an int, bool, or string is golang it is
	// important to ensure that the data type default value
	// is initialized properly. An integer literal should not
	// be wrapped in quotes for example.
	defaultType := "\"\""
	if o.Type == "int" {
		defaultType = "0"
	} else if o.Type == "bool" {
		defaultType = "false"
	}
	return OptionTemplateValue{
		TypeCap:     hyphenDelimToCamel(o.Type),
		ArgName:     hyphenDelimToCamel(o.Name),
		Name:        o.Name,
		Default:     defaultType,
		Description: o.Description,
		Required:    o.Required,
	}
}

func ToSwitch(cmds []*Command) (string, error) {
	var (
		switchList []SwitchTemplateEntry
		buff       bytes.Buffer
	)
	for _, cmd := range cmds {
		argList := cmd.ToArgList()
		switchList = append(switchList, SwitchTemplateEntry{
			Name:    hyphenDelimToCamel(cmd.Name),
			ArgList: argList,
		})
	}
	tmpl, err := template.New("switch").Parse(switchTemplate)
	if err != nil {
		return "", err
	}
	err = tmpl.Execute(&buff, switchList)
	if err != nil {
		return "", err
	}
	return buff.String(), nil
}

func (c *Command) ToVariables() (string, error) {
	var (
		buff    bytes.Buffer
		options []Option
	)

	// We need to do a pass to convert the variable names from cmd flags
	// to Go variable names.
	for _, opt := range c.Option {
		if _, ok := declaredVariables[opt.Name]; ok {
			continue
		}
		options = append(options, Option{
			Name: hyphenDelimToCamel(opt.Name),
			Type: opt.Type,
		})
		declaredVariables[opt.Name] = true
	}

	tmpl, err := template.New("option").Parse(varTemplate)
	if err != nil {
		return "", err
	}
	err = tmpl.Execute(&buff, options)
	if err != nil {
		return "", err
	}
	return buff.String(), nil
}
func (c *Command) ToGo() (string, error) {
	var (
		buff               bytes.Buffer
		subcommandVarNames []string
	)
	for _, subcmd := range c.Subcommands {
		subcommandVarNames = append(subcommandVarNames, hyphenDelimToCamel(subcmd))
	}

	// Convert the options to OptionTemplateValues
	var optionTemplateValueList []OptionTemplateValue
	for _, opt := range c.Option {
		optionTemplateValueList = append(optionTemplateValueList, opt.ToOptionTemplateValue())
	}

	tmpl, err := template.New("command").Parse(cmdTemplate)
	if err != nil {
		return "", err
	}
	err = tmpl.Execute(&buff, &CommandTemplateValues{
		Name:             c.Name,
		TopLevel:         c.TopLevel,
		Subcommands:      subcommandVarNames,
		VariableName:     hyphenDelimToCamel(c.Name),
		V4APIName:        c.V4APIName,
		ShortDescription: c.ShortDescription,
		Description:      c.Description,
		Option:           optionTemplateValueList,
	})
	if err != nil {
		return "", err
	}
	return buff.String(), nil
}

func LoadDefinitions(fname string) ([]*Command, error) {
	c := map[string][]*Command{}
	_, err := toml.DecodeFile(fname, &c)
	if err != nil {
		return nil, err
	}
	return c["command"], nil
}

// hyphenDelimToCamel will convert names like
// list-zones to ListZones, where the hyphen
// is removed and the first letter of each word
// is properly camel cased. Be aware that abbrvs
// like 'ttl' will be transformmed to 'Ttl'.
func hyphenDelimToCamel(s string) string {
	parts := strings.Split(s, "-")

	// Capitalize the first letter of each part and return the
	// concatenation of them.
	for i, part := range parts {
		parts[i] = strings.ToUpper(string(part[0])) + part[1:]
	}
	return strings.Join(parts, "")
}

func GenerateFile(fname string, outfile string) error {
	cmds, err := LoadDefinitions(fname)
	if err != nil {
		return err
	}
	commandsGo := ""
	variablesGo := ""
	// Do two passes. First we want to generate all code that is
	// not a top level command. Next we want to generate all top
	// level commands. This is because of the variable ordering
	// and avoiding undefined variable issues.
	for _, cmd := range cmds {
		if !cmd.TopLevel {
			s, err := cmd.ToGo()
			if err != nil {
				return err
			}
			commandsGo += s
		}
	}

	// While we do this second pass, create all the variables while
	// we are also creating all of the commands.
	for _, cmd := range cmds {
		v, err := cmd.ToVariables()
		if err != nil {
			return err
		}
		variablesGo += v
		if cmd.TopLevel {
			s, err := cmd.ToGo()
			if err != nil {
				return err
			}
			commandsGo += s
		}
	}

	switchList, err := ToSwitch(cmds)
	if err != nil {
		return err
	}

	t, err := fileText(commandsGo, variablesGo, switchList)
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(outfile, []byte(t), 0644)
	if err != nil {
		return err
	}
	return nil
}

func (c *Command) ToArgList() string {
	s := ""
	for _, opt := range c.Option {
		if s == "" {
			s = hyphenDelimToCamel(opt.Name)
		} else {
			s += ", " + hyphenDelimToCamel(opt.Name)
		}
	}
	return s
}

func (c *Command) ToArgListWithTypes() string {
	s := ""
	for _, opt := range c.Option {
		s += ", " + hyphenDelimToCamel(opt.Name) + " " + opt.Type
	}
	return s
}

func ToFuncSigs(cmds []*Command) string {
	s := ""
	for _, cmd := range cmds {
		s += fmt.Sprintf("func %s(api *cloudflare.API%s) (resp interface{}, err error) {\nreturn}\n", hyphenDelimToCamel(cmd.Name), cmd.ToArgListWithTypes())
	}
	return s
}
